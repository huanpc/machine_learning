<message>
<from> com </from>
<to> org </to>
<content-type> text/plain </content-type>
<subject>
<text_normal> 

^ [ autopackage ] libprefix - all the way 
</text_normal>
</subject>
<date> thu, 01 may 2003 14:41:31 -0400 </date>
<message_body>
<text_normal> 

^ sorry for not replying to the thread , i just subscribed and as such ca n't simply reply to it . 
^ &smiley 
^ also sorry this is all rather poorly thought out below , i 'm typing while the inspiration has me , because i know i 'll forget if i wait to put it together more formally . 
^ &smiley 
^ my thoughts on the libprefix thing are that , if it 's going to exist , it should go all the way . 
^ specifically , comments i saw in the archives like " no app will be spread over the filesystem " or that " paths can be relative to the binary " are all making assumptions on the location of the files ; they let the actual prefix be 'dymamic " , but not the installation structure . 
^ this is an unfortunately weak approach . 
^ looking at projects like linuxstep , or &name &name &char , where the archaic &name file system is abandoned for something a little more sane , one should consider that apps might have wildly different locations ( and relative paths ) between binaries , data files , libraries , and so on . 
^ things might still be relative , but those relative paths need to be different for these systems - on the &name , you 'd have $ prefix / bin , $ prefix / lib , etc. - in a next-ish system you might have something closer to $ prefix ( for bin ) , $ prefix / library , and so on . 
^ i 'd think it 'd be worth the effort to go all the way , and provide methods for finding any path using the library , given the same path names that autoconf projects - i.e. , a function for libdir , execdir , prefix , sharedstatedir , sysconfdir , and so on . 
^ the app authors know a lot better than we do which of those directories are important to them . 
^ this does of course raise the issue of _how_ to get this ; using /proc can only provide so much information , and even then it would only be a half guess . 
^ just because a binary is in /usr / bin or a lib is in /usr / lib , does n't mean the data wo n't be in /usr / share or /usr / share / app or /usr / local / app , and so on . 
^ the global database is a bit weak sounding , i 'll admit - too easy to break . 
^ some kind of extended metadata is still going to be needed , i fear . 
^ i can think of &num options ( there are likely many more ) : 
^ - put in some kind of metadata file , similar to a .desktop file or pkgconfig file , that has this , and apps / libs call a library routine that takes their unique &name to find and read this file . 
^ - embed the data straight in the executable , at install time . 
^ assuming only &name systems , this is _that_ hard , but still , it 's not _at all_ pretty . 
^ &name also allows tacking on of extra data to the end of the file , so you could use /proc to find the executable / library , look at a specific offset from the end of file , check for a magic cookie to ensure the data is valid , and read . 
^ this _also_ is n't pretty , tho ... 
^ the first one seems a lot better , tho it 's really just the global database ; on the upside , it should be a lot easier to use than a real &name , since it 's very similar to the pkgconfig or desktop menu systems , instead of like the fragile rpm db stuff . 
^ anyways , i really just do n't think that " where is the executable " and " where is the library " will honestly work , unless we enforce that autopackage files must be &name compliant . 
^ the big advantage to a system like this tho is ebing able to support systems with more intelligent file system hierarchies to be automagically supported , i think . 
^ the pain of war cannot exceed the woe of aftermath . 
^ - - led &name , " battle of &name " 
^ &name mailing list &email 
</text_normal>
</message_body>
</message>