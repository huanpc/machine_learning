<message>
<from> com </from>
<to> org </to>
<content-type> text/plain </content-type>
<subject>
<text_normal> 

^ [ autopackage ] scanning elf 
</text_normal>
</subject>
<date> fri, 02 may 2003 16:33:51 -0400 </date>
<message_body>
<text_normal> 

^ on &name , &num at &num : &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ on &name , &num at &num : &num , &name &name wrote : 
<text_embedded> 

^ you can get the address of a function then figure out the object by looking at the addresses in the map list . 
^ we experimented with poking linker structures to no avail . 
^ at some point when i learn the art of glibc hacking if &name has n't already done it i 'll add dlinfo ( ) which lets us get the origin as defined by &name , which should be good enough . 
</text_embedded>

^ i 'm able to get this to work ; it looks like the library procedure address are always mapped into the executable 's address range ... how would i go about getting the address of a function in the library 's address range , versus the exectuable 's? 
^ for reference , i have a shared object ( libtest.so ) , and it 's calling libprefix using a symbol defined in that library , and the range is in the executable 's range . 
^ same thing happens if i use a symbol from glibc or whatnot . 
^ &smiley 
</text_embedded>
<text_normal> 

^ ok , sorry for replying to myself . 
^ 
^ 
^ ; 
^ i have this half figured out now ; what looks like needs be done is the &name header of the executable in memory must be scanned to find the symbol table and mappings and all that other fun stuff . 
^ so i 'm thinking i need to spend some time learning &name and object internals before i can get much further on this part of it all . 
^ &smiley 
^ any pointers and where i could read up on the specific issues involved ? 
^ the pain of war cannot exceed the woe of aftermath . 
^ - - led &name , " battle of &name " 
^ &name mailing list &email 
</text_normal>
</message_body>
</message>