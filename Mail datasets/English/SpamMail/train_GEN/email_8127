<message>
<content-type> text/plain; charset="us-ascii" </content-type>
<subject>
<text_normal> 

^ &name &name : s&v worked example 
</text_normal>
</subject>
<date> mon, 28 jan 2002 12:35:42 -0000 </date>
<from> ac.uk </from>
<to> ac.uk </to>
<message_body>
<text_normal> 

^ part &num students - &name and verif . 
^ worked example - courtesy of &name &name 
^ - ------ forwarded message 
^ from : &name &name ( &email ) &name : mon , &num &name &num &num : &num : &num &num to : &name &name ( &email ) subject : s&v worked example 
^ i failed to finish a factorial verification in a previous class , and promised that i 'd provide a worked version at a later stage . 
^ here it is . 
^ could you forward this to the part &num students please ? 
^ thanks , &name . 
^ - ---------------------------------------------------------------------- 
^ want to show 
^ { &char &num &char / &char )3d &num } fact : &num &num ; while &char ) &num do &char : &num fact ; &name : &num &char ; while &char ) &num do fact : &num fact + &char ; &name : &num &char - &num ; &char : &num &char - &num { fact &num &char ! 
^ } 
^ ( from &name &num ) 
^ at top level , program is &num statements . 
^ ca n't push post-condition back over loop , but can easily generate intermediate condition by pushing pre-condition forward over assignment , getting 
^ { &char &num &char / &char )3d &num / fact &num &num } 
^ now : 
^ { &char &num &char / &char )3d &num } fact : &num &num { &char &num &char / &char )3d &num / fact &num &num } 
^ follows immediately because substitution backwards requires us to have our precondition imply fact &num fact . 
^ our remaining task is to prove 
^ { &char &num &char / &char )3d &num / fact &num &num } while &char ) &num do &char : &num fact ; &name : &num &char ; while &char ) &num do fact : &num fact + &char ; &name : &num &char - &num ; &char : &num &char - &num { fact &num &char ! 
^ } 
^ need to generate an invariant . 
^ do this by trying a test-run by hand . 
^ let 's take &char &num &num . 
^ then as the outer loop executes , we get the following sequence of values ( at the start of the loop ) 
^ loop iteration number &char fact 
^ - ---------------------------------------- &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num 
^ we spot that &char ! 
^ &num &char ! 
^ * fact , and take this as our proposed invariant . 
^ we need to test &num conditions : 
^ &char ) that the invariant holds initially , i.e. , 
^ &char &num &char / &char )3d &num / fact &num &num 3d3d ) &char ! 
^ &num &char ! 
^ * fact 
^ which is clearly true 
^ and 
^ ii ) that the invariant and the negation of the guard establishes the post-condition , i.e. , 
^ &char ! 
^ &num &char ! 
^ * fact / &char ( &num &num 3d3d ) fact &num &char ! 
^ which is true , so long as we assume that &char must be a natural number . 
^ ( then &char must be either &num or &num , so &char ! 
^ will be &num . ) if you 're unwilling to assume &char a natural ( &char 's unsigned type would be fine here ) you 'll need to add &char )3d &num to the invariant , and then check that &char ) still held ( it does) . 
^ finally , we have to verify that the invariant is preserved by the loop body . 
^ that is : 
^ { &char ! 
^ &num &char ! 
^ * fact / &char ) &num } &char : &num fact ; &name : &num &char ; while &char ) &num do fact : &num fact + &char ; &name : &num &char - &num ; &char : &num &char - &num { &char ! 
^ &num &char ! 
^ * fact } 
^ ( we get to also assume that the guard of the loop is true on entry to the loop body . ) 
^ we can push the post-condition up past the last assignment in the loop : 
^ { &char ! 
^ &num &char ! 
^ * fact / &char ) &num } &char : &num fact ; &name : &num &char ; while &char ) &num do fact : &num fact + &char ; &name : &num &char - &num ; { &char ! 
^ &num ( n-1 ) ! 
^ * fact } 
^ we can also trivially push the pre-condition forward over &num simple assignments ( note that the variable being assigned too is n't mentioned on the &name , this is what permits this simple forward reasoning ; it would n't be valid otherwise ) : 
^ { &char ! 
^ &num &char ! 
^ * fact / &char ) &num / &char &num fact / &char &num &char } while &char ) &num do fact : &num fact + &char ; &name : &num &char - &num ; { &char ! 
^ &num ( n-1 ) ! 
^ * fact } 
^ then we need to generate another loop invariant . 
^ let 's generate another test-run , say when fact &num &num , &char &num &num . 
^ loop iteration number fact &char &char &char &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num 
^ it 's easy enough to spot here that fact + &char is retaining a constant value . 
^ but there should be a multiplication in here somewhere , so let 's take a look at another iteration . 
^ when fact &num &num and &char &num &num . 
^ loop iteration number fact &char &char &char &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num &num 
^ here it 's clear that it 's fact + &char * &char which has the constant value . 
^ what 's a formula for the constant value . 
^ here it 's &num , before it was &num . 
^ both turn out to be &num * ( &char + &name . 
^ so , that 's our proposed invariant 
^ fact + &char * &char &num &char * ( &char + &num ) 
^ or alternatively : 
^ fact &num &char * ( &char + &num - &char ) 
^ we need to have it true initially , that 
^ &char ! 
^ &num &char ! 
^ * fact / &char ) &num / &char &num fact / &char &num &char 3d3d ) fact &num &char * ( &char + &num - &char ) 
^ which is clearly true . 
^ but we also need it and the negation of the loop guard to imply the post-condition . 
^ that is , 
^ fact &num &char * ( &char + &num - &char ) / &char ( &num &num 3d3d ) &char ! 
^ &num ( n-1 ) ! 
^ * fact 
^ but this is n't anywhere near holding . 
^ first , we need to nail down &name 's value , a little more precisely . 
^ add &num ( &num &char to the invariant . 
^ this holds initially ( because &char ) &num ) , and because 
^ &char ( &num &num / &num ( &num &char 3d3d ) ( &char &num &num ) 
^ this modifies the post-condition calculation to 
^ ( fact &num &char * &char ) 3d3d ) ( &char ! 
^ &num ( &char - &num ) ! 
^ * fact ) 
^ but we still do n't have enough information here . 
^ in particular , we need to know more about &name if we look at the loop again , we see that it does n't change &name moreover , when the loop began i was equal to fact , and we had a nice fact about the relationship of fact to n! . 
^ so we can add 
^ &char ! 
^ &num &char ! 
^ * &char 
^ to our invariant . 
^ this also clearly holds initially . 
^ then our post-condition calculation simplifies to 
^ ( fact &num &char * &char ) / ( &char ! 
^ &num &char ! 
^ * &char ) 3d3d ) ( &char ! 
^ &num ( &char - &num ) ! 
^ * fact ) 
^ eliminating the assumed equalities , this becomes 
^ &char ! 
^ * &char &num ( &char - &num ) ! 
^ * &char * &char 
^ if we 're willing to have n a natural number , and to define &num - &num &num &num , then this is provable . 
^ if not , we would need to add &char )3d &num to our invariant , which is true initially . 
^ now we can finally verify the loop body : 
^ { ( fact &num &char * ( &char + &num - &char ) ) / &num ( &num &char / &char ! 
^ &num &char ! 
^ * &char / &char ) &num } 
^ fact : &num fact + &char ; &name : &num &char - &num ; 
^ { ( fact &num &char * ( &char + &num - &char ) ) / &num ( &num &char / &char ! 
^ &num &char ! 
^ * &char } 
^ pushing the post-condition backwards , and doing the substitutions , we need the following implication to be true : 
^ ( fact &num &char * ( &char + &num - &char ) ) / &num ( &num &char / &char ! 
^ &num &char ! 
^ * &char / &char ) &num 3d3d ) 
^ ( fact + &char &num &char * ( &char + &num - ( &char - &num ) ) ) / &num ( &num &char - &num / &char ! 
^ &num &char ! 
^ * &char 
^ algebra then verifies that each of the conjuncts in the conclusion of the implication do hold if we assume the antecedent . 
^ ( if you 're really worried about natural number subtraction , then you will need one further clause still ; that &char ( &num &name ) 
^ &char &name &name . 
^ &name . 
^ - ------ end of forwarded message 
</text_normal>
</message_body>
</message>