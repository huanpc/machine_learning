<message>
<from> com </from>
<subject>
<text_normal> 

^ re : [ autopackage ] libprefix - all the way 
</text_normal>
</subject>
<to> org </to>
<content-type> text/plain </content-type>
<date> fri, 02 may 2003 15:34:19 -0400 </date>
<message_body>
<text_normal> 

^ on &name , &num at &num : &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ you can get the address of a function then figure out the object by looking at the addresses in the map list . 
^ we experimented with poking linker structures to no avail . 
^ at some point when i learn the art of glibc hacking if &name has n't already done it i 'll add dlinfo ( ) which lets us get the origin as defined by &name , which should be good enough . 
</text_embedded>
<text_normal> 

^ i 'm able to get this to work ; it looks like the library procedure address are always mapped into the executable 's address range ... how would i go about getting the address of a function in the library 's address range , versus the exectuable 's? 
^ for reference , i have a shared object ( libtest.so ) , and it 's calling libprefix using a symbol defined in that library , and the range is in the executable 's range . 
^ same thing happens if i use a symbol from glibc or whatnot . 
^ &smiley 
^ the pain of war cannot exceed the woe of aftermath . 
^ - - led &name , " battle of &name " 
^ &name mailing list &email 
</text_normal>
</message_body>
</message>