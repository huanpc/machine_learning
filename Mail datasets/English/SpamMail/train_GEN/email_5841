<message>
<subject>
<text_normal> 

^ re : [ autopackage ] scanning elf 
</text_normal>
</subject>
<from> com </from>
<to> org </to>
<content-type> text/plain </content-type>
<date> 02 may 2003 22:35:58 +0100 </date>
<message_body>
<text_embedded> 

^ i have this half figured out now ; what looks like needs be done is the &name header of the executable in memory must be scanned to find the symbol table and mappings and all that other fun stuff . 
</text_embedded>
<text_normal> 

^ what 's happening is that the address is a reference to the objects global offset table . 
^ the &name is n't guaranteed to point to the address in global space of course , it could also point to the procedure linkage table ( &name ) which implements lazy linkage . 
^ we could get the address by ensuring the function is called or getting the &name entry invoked some other way and then dissembling the &name entry but that 's messy and non-portable . 
</text_normal>
<text_embedded> 

^ so i 'm thinking i need to spend some time learning &name and object internals before i can get much further on this part of it all . 
^ &smiley 
^ any pointers and where i could read up on the specific issues involved ? 
</text_embedded>
<text_normal> 

^ &website 
^ &website / 
^ this is all &name anyway , we only care about our own address , not that of other libraries . 
^ once we 've located that , we can find our absolute path in the maps list and the other libraries can sort themselves out . 
^ you can do this to get the base address of the current context object : 
^ # include ( dlfcn.h ) 
^ &name dli ; dladdr ( &main, &dli) ; dli.dli_fbase the base address of the object 
^ ... which corresponds to the values in the first column of /proc / self / maps &smiley 
^ &name mailing list &email 
</text_normal>
</message_body>
</message>