<message>
<date> tue, 6 aug 2002 13:30:35 -0400 (edt) </date>
<from> edu </from>
<to> edu </to>
<subject>
<text_normal> 

^ re : &name &name 
</text_normal>
</subject>
<content-type> text/plain; charset=us-ascii </content-type>
<message_body>
<text_normal> 

^ hi &name , 
^ no problem , let me explain more the utility of the keys for aggregate boxes . 
^ not all aggregate boxes are preceded by a restream , sometimes the boxes will just work on keys how they are . 
^ take the example of an aggregate box that calculates the average heartbeat of each soldier . 
^ the soldiers might just be distinguished by &name , so the box can automatically keep &num state per &name ( soldier ) . 
^ as far as othogonal grouping , consider tumble which closes the " current state " every time it sees a new set of group by attributes . 
^ if the new set of group by attributes differs by a stream identifier attribute ( or the set of attributes that restream currently groups into an &name ) , this is not what you want to happen . 
^ stream identifier attributes are 'special " because seeing a new one with an aggregate box does not necessarily close a state - because multiple states are maintained simultaneously ; &num per stream id . 
^ consider the following example : 
^ &num . 
^ ( &name &num , &char &num ) &num . 
^ ( &name &num , &char &num ) &num . 
^ ( &name &num , &char &num ) 
^ note that none of these tuples needs to close a state , but if you treat &name as a regular group by attribute , you will be closing states after tuples &num and &num . 
^ thus &name ( or if we remove it , the additional grouping that is done by restream ) is orthogonal to the regular group-by attributes of tumble . 
^ regarding your question about joins , &name says that we have no idea how join will work yet - it might not even be windowed . 
^ &name 
^ on mon , &num &name &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ i think i was wrong . 
^ just forget what i said . 
^ sorry . 
^ returning to your first question , i do n't think i can judge whether the negatives of increasing the complexity of the aggregate boxes outweigh the positives of doing that or not . 
^ i just want to hear others " opinions in the meeting . 
^ but personally , i do n't like to have stream ids because their relative utility seems low to me ( they are hidden from box modifiers ) . 
^ in the mean time i do n't think i fully understand the complexity of the aggregate boxes ( having &num orthoganal groupings ) . 
^ could you show me some examples ? 
^ i think it will be helpful for the others also . 
^ thank you , 
^ &name . 
^ p.s. do you know if joins ( which are windowed ) can work fine with tuples not sorted by the timestamp order ? 
^ if you have a join with &num min time winodw such that the timestamp sequences of both the left and right input tuples are commonly ( &num : &num pm , &num : &num pm , &num : &num pm , &num : &name , &num : pm , &num : &name , . ... ) , what would you do ? 
<text_embedded> 

^ hi &name , 
^ i am not sure what you mean , but i think you are saying that for aggregate operators , timestamps need to be kept around for each &name . 
^ but i think that 's only because there is &num state for each &name , so even if we do n't have &name we will still have more than &num state . 
^ so i 'm not sure how throwing away this system will help . 
^ &name 
^ on mon , &num &name &num , &name &name wrote : 
<text_embedded> 

^ thanks &name . 
^ i am wondering if the stream id matters might be quite bigger than what we think now . 
^ for example , in order to do " operator optimization ( operator reordering ) " and 'recovery " , we have to have something like backups / connection points ( history archives ) to replay the previous executions for a while . 
^ &num issue for the things is that we have to find the earliest timestamp ( of tuples 
^ that the operators are currently dependent on ) for each of the backups . 
^ if we keep using stream ids , i wonder if we may have to keep track of the earilest times for all the stream ids . 
^ if my thought is correct , i would rather throw the system away . 
^ so , i hope i am wrong &smiley 
^ thanks , 
^ &name . 
<text_embedded> 

^ hi &name , 
^ i met with &name earlier today to discuss the stream id matter that we were talking about . 
^ i think that we agreed that we could probably implement the system without stream ids , but the complexity that moving restream into the aggregate boxes ( and hence having these aggregate boxes perform &num different othogonal grouping operations ) would be large and users might have trouble thinking about queries in terms of these complex operators . 
^ it seems difficult to compare the benefits from removing stream ids with the negatives of increasing the complexity of these aggregate boxes but it seems that the negatives outweigh the positives . 
^ what do you think ? 
^ &name 
</text_embedded>

</text_embedded>

</text_embedded>

</text_embedded>
</message_body>
</message>