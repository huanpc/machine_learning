<message>
<date> wed, 24 jul 2002 13:54:52 -0400 (edt) </date>
<from> edu </from>
<to> edu </to>
<subject>
<text_normal> 

^ re : c++ catalog manager 
</text_normal>
</subject>
<content-type> text/plain; charset=us-ascii </content-type>
<message_body>
<text_normal> 

^ hi &name , 
^ i think &name systems have a char bigger than &num byte . 
^ i agree - we probably should be using byte arrays instead of &name arrays everywhere ... &name how hard do you think it will be to change everything to pass around a byte * instead of a char * ? 
^ &name 
^ &name sat , &num &name &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ thank you very much for the details . 
^ by the way , is there a system where sizeof ( &name ) ) &num ? 
^ if so , i think basically we should use byte rather than &name . 
^ thanks . 
^ have a nice weekend . 
^ &name . 
^ on &name , &num &name &num , &name &name wrote : 
<text_embedded> 

^ hi &name , 
^ thanks for the update . 
^ we used some sample tuples to test our code , and we came to a more exact definition of offset and size . 
^ we defined offset as the number of characters into the char * that the attribute begins ( counting from &num ) . 
^ since right now sizeof ( &name ) is &num ( byte ) so you can just calculate the offset by doing sizeof ( att ) for all the attributes before it . 
^ for instance , if the the tuple description is ( float) ( int) ( float ) and we are trying to calculate the second float attribute then the offset would be sizeof ( float ) + sizeof ( int ) and the size would be sizeof ( float ) so the string that is written to the database is : &num : &char : &char : &char : where &char is the string representation of the offset calc and &char is the string representation of the size calc . 
^ but to be safe , it is probably safer to divide by sizeof ( &name ) in case its size is more than &num byte on different systems . 
^ so the above offset would be ( sizeof ( int ) + sizeof ( float ) / sizeof ( &name ) and similarly for the size . 
^ obviously , strings have to be dealt with separately . 
^ its size has to be looked up in the tuple description . 
^ also , according to &name , we ca n't assume that strings end with " &num " in the tuples - but i do n't think that should affect your calculations at all . 
^ let me know if i can be of any help . 
^ &name 
^ on &name , &num &name &num , &name &name wrote : 
<text_embedded> 

^ &name &name . 
<text_embedded> 

^ in response to # &num - that is exactly how the parser works . 
^ it takes a string and returns the &name object . 
^ as you asked , the code is attached with this email . 
^ did you ever get around to rewriting attribute extracts in the predicate / expression string as : &num : &char : &num : &num : where the size and offsets are now compatable with the new way of looking at tuples ? 
^ &name 
</text_embedded>

^ i am sorry i did n't do that yet . 
^ i have been busy doing the c++ sleepycat-related classes . 
^ i think i can do that by today . 
^ i am sorry for the delay . 
^ &name . 
</text_embedded>

</text_embedded>

</text_embedded>
</message_body>
</message>