<message>
<to> ac.uk </to>
<subject>
<text_normal> 

^ revised paper 
</text_normal>
</subject>
<content-type> text/plain; charset=us-ascii </content-type>
<date> tue, 01 may 2001 21:08:00 +0100 </date>
<from> ac.uk </from>
<message_body>
<text_normal> 

^ here it is again , i think this is now ok ( or at least i 'm so bored with it i never want to see it again ... ) . 
^ i ended up losing the footnote about infinite complements because i think few &name will care , but otherwise just added a couple of sentences to try and clarify &name 's issues , added the acknowls and then spent ages farting about with the formatting to get back to &num pages , though i think i 've actually improved it in places . 
^ note that they keep changing the damn style file on the web , so you should make sure you have the latest version 
^ so send it off when you like . 
^ i 'll do the pdf , shall i ? 
^ but i 'll wait till you let me know you 're happy with the hardcopy 
^ &name 
^ % &name paper proper ; version &num documentclass [ 11pt]{ article } usepackage { acl2001 } usepackage { times } usepackage { latexsym } 
^ %&website } % expanding the titlebox 
^ title { an algebra for semantic construction in grammars } author { ann &name &org university of &name &name &name &name &name &name , &name , &name { small { tt &name and &name &name division of &name university of &name &num &name &name &name , &name , &name { small { tt &name and &name &name &name , &name university { em and } &name &name &name &name , &num &name &name &name , ca &num , &name { small { tt &name 
^ date {} 
^ newcommand { lsembrac } { mbox { [ &name &num em [ }} newcommand { rsembrac } { mbox { ] &name &num em ]}} newcommand { sem } [ &num ] {{ lsembrac # &num rsembrac }} 
^ % used as in , e.g. , sem { phi } 
^{ rm dpl } _ { m , &char , t } 
^ % csmodels is for putting in inference patterns , and csmodel is for % running text &website } mbox { $ mid $ &name &num em $ &name newcommand { csmodel } { mbox { $ mid $ &name &num em $ approx $ }} 
^ &website } mbox { $ mid $ &name &num em $ &name 
^ newcommand { happyface } { mbox { large $ bigcirc $ smallraisebox {-0.02in }{ hspace * {-0.17in } $ smile $ } raisebox { 0.06in }{ hspace * {-0.17in }.hspace * { 0.03in }.}} normalsize hspace { 0.05in }} 
^ [ 1]{} 
^ newtheorem { translation }{ translation } newtheorem { theorem }{ theorem } newtheorem { lemma }{ lemma } newtheorem { corollary }{ corollary } 
^ % &name macros &name renewcommand { arraystretch }{ 1.1 } %1.2 left [ begin { array }{ l } [ -2mm ] # &num [ -2mm ] end { array } right ] newcommand { att } [ 1]{{ mbox { tiny { bf # &name newcommand { attval } [ 2]{{ mbox { tiny # &name {{# &name newcommand { attvallist } [ 2]{{ mbox { tiny # &name { ( {# &name newcommand { attvaltlist } [ 2]{{ mbox { tiny # &name { ( { myvaluebold {# &name newcommand { attvaltyp } [ 2]{{ mbox { tiny # &name { myvaluebold {# &name newcommand { attvalshrunktyp } [ 2]{{ mbox { tiny # &name { boxvaluebold {# &name newcommand { myvaluebold } [ 1]{{ mbox { tiny { bf # &name newcommand { boxvaluebold } [ 1]{{ fbox { tiny { bf # &name newcommand { ind } [ &name : fbox {{ tiny # &name :}} 
^ 
^ newcommand { qeq }{ _ { q }} newcommand { tuple } [ 1]{ langle # &num rangle } 
^ 
^ maketitle begin { abstract } we develop a framework for formalizing semantic construction within grammars expressed in typed feature structure logics , including { sc hpsg } . 
^ the approach provides an alternative to the lambda calculus ; it maintains much of the desirable flexibility of unification-based approaches to composition , while constraining the allowable operations in order to capture basic generalizations and improve maintainability . 
^ end { abstract } 
^ 
^ some grammar formalisms incorporate both syntactic and semantic representations within the same structure . 
^ for instance , figure~1 shows of typed feature structures ( { sc tfs } s ) for { it &name , { it sleeps } and the phrase { it &name sleeps } , in an { sc hpsg }-like representation , loosely based on &name and &name ( &num ) . 
^ the semantic representation expressed is intended to be equivalent to $ r_name ( &char , &name ) wedge sleep ( &char , x) $ &name variables are free , we will discuss scopal relationships and quantifiers below.} note : begin { enumerate } topsep &name plus &name minus &name &website item variable equivalence is represented by coindexation within a { sc tfs } . 
^ item the coindexation in { it &name sleeps } is achieved as an effect of instantiating the { sc subj } slot in the sign for { it sleeps } . 
^ item structures representing individual predicate applications ( henceforth , elementary predications , or { sc ep } s ) are accumulated by an append operation . 
^ conjunction of { sc ep } s is implicit . 
^ item all signs have an index functioning somewhat like a $ lambda $ -variable . 
^ begin { figure * } &name { tiny $ avmplus { attval { syn }{ avmplus { att { np } attvaltyp { head }{ noun } attvallist { subj }{} attvallist { comps }{}}} attval { sem }{ avmplus { attval { index }{ ind { 5 }} myvaluebold { ref-ind } attvallist { restr }{ avmplus { attvaltyp { reln }{ r_name } attval { instance }{ ind { 5 }} attvaltyp { name }{ kim }}}}}} $ } &name sleeps { tiny $ avmplus { attval { syn }{ avmplus { attvaltyp { head }{ verb } attvallist { subj }{ avmplus { attvaltyp { syn }{ np } attval { sem }{ avmplus { attval { index }{ ind { 6 }} attval { restr }{ ind { 7 }}}}}} attvallist { comps }{}}} attval { sem }{ avmplus { attval { index }{ ind { 15 }} myvaluebold { event } attvallist { restr }{ avmplus { attvaltyp { reln }{ sleep } attval { sit }{ ind { 15 }} attval { act }{ ind { 6 }}} }}}} $ } &name sleeps { tiny $ avmplus { attval { syn }{ avmplus { attval { head }{ ind { 0 }} myvaluebold { verb }}} attval { sem }{ avmplus { attval { index }{ ind { 2 }} myvaluebold { event } attval { restr }{ ind { 10 } ( avmplus { attvaltyp { reln }{ r_name } attval { instance }{ ind { 4 }} attvaltyp { name }{ kim }} ) append ind { 11 } ( avmplus { attvaltyp { reln }{ sleep } attval { sit }{ ind { 2 }} myvaluebold { event } attval { act }{ ind { 4 }}} )}}} &website }{ avmplus { attval { index }{ ind { 2 }} attval { restr }{ ind { 10 }}}} &website.restr }{ ind { 11 }}} caption { expressing semantics in { sc tfs } s } end { figure * } 
^ &char similar approach has been used in a large number of implemented grammars ( see &name ( &num ) for a fairly early example ) . 
^ it is in many ways easier to work with than $ lambda $ -calculus based approaches ( which we discuss further below ) and has the great advantage of allowing generalizations about the syntax-semantics interface to be easily expressed . 
^ but there are problems . 
^ the operations are only specified in terms of the { sc tfs } logic : the interpretation relies on an intuitive correspondence with a conventional logical representation , but this is not spelled out . 
^ furthermore the operations on the semantics are not tightly specified or constrained . 
^ for instance , although { sc hpsg } has the semantics &name ( &name and &name , &num ) this does not stop the composition process accessing arbitrary pieces of structure , so it is often not easy to conceptually disentangle the syntax and semantics in an { sc hpsg } . 
^ nothing guarantees that the grammar is { it monotonic } , by which we mean that in each rule application the semantic content of each daughter subsumes some portion of the semantic content of the mother ( i.e. , no semantic information is dropped during composition ) : this makes it impossible to guarantee that certain generation algorithms will work effectively . 
^ finally , from a theoretical perspective , it seems clear that substantive generalizations are being missed . 
^ &name &name &name ( { sc mrs } : &name et &name ( &num ) , see also egg ( &num ) ) tightens up the specification of composition a little . 
^ it enforces monotonic accumulation of { sc ep } s by making all rules append the { sc ep } s of their daughters ( an approach which was followed by &name and &name ( &num ) ) but it does not fully specify compositional principles and does not formalize composition . 
^ we attempt to rectify these problems , by developing an algebra which gives a general way of expressing composition . 
^ the semantic algebra lets us specify the allowable operations in a less cumbersome notation than { sc tfs } s and abstracts away from the specific feature architecture used in individual grammars , but the essential features of the algebra can be encoded in the hierarchy of lexical and constructional type constraints . 
^ our work actually started as an attempt at rational reconstruction of semantic composition in the large grammar implemented by the lingo project at { sc csli } ( available via { tt &website semantics and the syntax / semantics interface have accounted for approximately &num of the development time of the english resource grammar ( { sc erg } ) , largely because the account of semantics within { sc hpsg } is so underdetermined . 
^ in this paper , we begin by giving a formal account of a very simplified form of the algebra and in sref { interp-section } , we consider its interpretation . 
^ in sref { holes-section } to sref { control-section } , we generalize to the full algebra needed to capture the use of { sc mrs } in the lingo english resource grammar ( { sc erg } ) . 
^ finally we conclude with some comparisons to the $ lambda $ -calculus and to other work on unification based grammar . 
^ section { a simple semantic algebra } label { simple } 
^ the following shows the equivalents of the structures in figure~1 in our algebra : $ begin { array }{@{} l l@{}} mbox { kim:} & [ x_2]{ [ ]_ { subj } , [ ]_ { comp }} [ mbox {{ em r_name }} ( &name , mbox {{ em kim }})]{} end { array } $ $ begin { array }{@{} l l@{}} mbox { sleeps:} & [ e_1]{ [ &name , [ ]_ { comp }} [ mbox {{ em sleep }} ( &name , &name end { array } $ $ begin { array }{@{} l l@{}} mbox { kim sleeps:} [ e_1]{ [ ]_ { subj } , [ ]_ { comp }} [ mbox {{ em sleep }} ( &name , x_1 ) , & &website } mbox {{ em r_name }} ( &name , mbox {{ em kim }})]{ x_1x_2 } end { array } $ the last structure is semantically equivalent to : $ [ mbox {{ em sleep }} ( &name , x_1 ) , mbox {{ em r_name }} ( &name , mbox {{ em kim }})] $ . 
^ in the structure for { it sleeps } , the first part , $ [ e_1] $ , is a { it hook } and the second part ( $ [ x_1]_ { subj } $ and $ [ ]_ { comp } $ ) is the { it hole } s . 
^ the third element ( the { it lzt } ) is a bag of elementary predications ( { sc ep } s ).footnote { as usual in { sc mrs } , this is a bag rather than a set because we do not want to have to check for / disallow repeated { sc ep } s ; e.g. , { em big big car }.} intuitively , the hook is a record of the value in the semantic entity that can be used to fill a hole in another entity during composition . 
^ the holes record gaps in the semantic form which occur because it represents a syntactically unsaturated structure . 
^ some structures have no holes , such as that for { it &name . 
^ when structures are composed , a hole in &num structure ( the semantic head ) is filled with the hook of the other ( by equating the variables ) and their lzts are appended . 
^ it should be intuitively obvious that there is a relationship between this algebra and the { sc tfs } s shown in figure~1 , although there are other { sc tfs } architectures which would share the same encoding . 
^ we now give a formal description of the algebra . 
^ in this section , we simplify by assuming that each entity has only &num hole , which is unlabelled , and only consider &num sorts of variables : events and individuals . 
^ the set of semantic entities is built from the following vocabulary : begin { enumerate } topsep &name plus &name minus &name &website item the absurdity symbol $ bot $ . 
^ item indices $ i_1 , &name , ldots $ , consisting of &num subtypes of indices : events $ e_1 , &name , ldots $ and individuals $ x_1 , &name , ldots $ . 
^ item $ &char $ -place predicates , which take indices as arguments item $ $ . 
^ equality can only be used to identify variables of compatible sorts : e.g. , $ x_1x_2 $ is well formed , but $ ex $ is not . 
^ sort compatibility corresponds to unifiability in the { sc tfs } logic . 
^ elementary predications ( { sc sep })} label { seps } an { sc sep } contains &num components : begin { enumerate } topsep &name plus &name minus &name &website item a relation symbol item a list of &num or more ordinary variable arguments of the relation ( i.e. , indices ) end { enumerate } this is written relation ( arg $ &num , ldots, $ arg $ &char $ ) . 
^ for instance , $ mbox { like } ( &char , &char , y) $ is a well-formed { sc sep } . 
^ end { defn } 
^ { bf equality conditions:} where $ i_1 $ and $ i_2 $ are indices , $ i_1i_2 $ is an equality condition . 
^ set $ sigma $ of simple semantic entities ( { sc ssement })} $ sinsigma $ if and only if $ sbot $ or $ &char langle &name , &name , &name , s_4rangle $ such that : begin { itemize } topsep &name plus &name minus &name &website item $ s_1 { [ i]} $ is a hook ; item $ s_2 emptyset $ or $ { [ i' ]} $ is a hole ; item $ s_3 $ is a bag of { sc sep } s ( the lzt ) item $ s_4 $ is a set of equalities between variables ( the eqs ) . 
^ end { itemize } end { defn } 
^ we write a { sc ssement } as : $ [ i_1] [ i_2] [ mbox {{ sc sep }{ it s }}]{ mbox {{ sc eq }{ it s }}} $ . 
^ note for convenience we omit the set markers $ {} $ from the hook and hole when there is no possible confusion . 
^ the { sc sep } s , and { sc eq } s are ( partial ) { em descriptions } of the fully specified formulae of first order logic . 
^ begin { defn }{ bf the semantic algebra } a semantic algebra defined on vocabulary $ v $ is the algebra $ langle sigma , oprangle $ where : begin { itemize } topsep &name plus &name minus &name &website item $ sigma $ is the set of { sc ssement } s defined on the vocabulary $ v $ , as given above ; item $ op : sigmatimessigma longrightarrow sigma $ is the operation of semantic composition . 
^ it satisfies the following conditions . 
^ if $ a_1bot $ or $ a_2bot $ or $ mbox {{ em hole }} ( a_2 ) emptyset $ , then $ op ( &name , &name ) bot $ . 
^ otherwise : begin { enumerate } topsep &name plus &name minus &name &website item $ mbox {{ em hook }} ( op ( &name , &name ) ) mbox {{ em hook }} ( a_2) $ item $ mbox {{ em hole }} ( op ( &name , &name ) ) mbox {{ em hole }} ( a_1) $ item $ mbox {{ em lzt }} ( op ( &name , &name ) ) mbox {{ em lzt }} ( a_1 ) oplus mbox {{ em lzt }} ( a_2) $ item $ mbox {{ em eq }} ( op ( &name , &name ) ) &name ( eq ( a_1 ) cup eq ( a_2 ) cup $ $ mbox {{ em hook }} ( a_1 ) mbox {{ em hole }} ( a_2)}) $ where $ &name $ stands for { em transitive closure } ( i.e. , if $ s { xy , yz } $ , then $ &name ( s){ xy , yz , xz } $ ) . 
^ end { itemize } end { defn } this definition makes $ a_2 $ the equivalent of a semantic functor and $ a_1 $ its argument . 
^ $ op $ is a function } label { op-is-function } if $ a_1a_3 $ and $ a_2a_4 $ , then $ a_5op ( &name , &name ) op ( &name , &name ) a_6 $ . 
^ thus $ op $ is a function . 
^ furthermore , the range of $ op $ is within $ sigma $ . 
^ so $ langle sigma , oprangle $ is an algebra . 
^ end { theorem } 
^ we can assume that semantic composition always involves &num arguments , since we can define composition in ternary rules etc as a sequence of binary operations . 
^ grammar rules ( i.e. , constructions ) may contribute semantic information , but we assume that this information obeys all the same constraints as the semantics for a sign , so in effect such a rule is semantically equivalent to having null elements in the grammar . 
^ the correspondence between the order of the arguments to $ op $ and linear order is specified by syntax . 
^ we use variables and equality statements to achieve the same effect as coindexation in { sc tfs } s . 
^ this raises &num problem , which is the need to avoid accidental variable equivalences ( e.g. , accidentally using $ &char $ in both the signs for { it cat } and { it dog } when building the logical form of { em a dog chased a cat } ) . 
^ we avoid this by adopting a convention that each instance of a lexical sign comes from a set of basic { em sement } s that have pairwise distinct variables . 
^ the equivalent of coindexation within a lexical sign is represented by repeating the same variable but the equivalent of coindexation that occurs during semantic composition is an equality condition which identifies &num different variables . 
^ stating this formally is straightforward but a little long-winded , so we omit it here . 
^ label { interp-section } 
^ the { sc sep } s and { sc eq } s can be interpreted with respect to a first order model $ langle &char , &char , frangle $ where : begin { enumerate } topsep &name plus &name minus &name &website item $ &char $ is a set of events item $ a $ is a set of individuals item $ f $ is an interpretation function , which assigns tuples of appropriate kinds to the predicates of the language . 
^ 
^ the { bf truth definition } of the { sc sep } s and { sc eq } s ( which we group together under the term { sc smrs } , for simple { sc mrs } ) is as follows : begin { enumerate } topsep &name plus &name minus &name &website item for all events and individuals $ &char $ , $ sem { v } 
^{ langle &char , grangle } &char ( v) $ . 
^ item for all $ &char $ -predicates $ &char 
^n $ , $ sem { p 
^n } 
^{ langle &char , grangle } { langle &name , ldots , t_nrangle : langle &name , ldots , t_nranglein f ( &char 
^n)} $ . 
^ item $ sem { p 
^n ( &name , ldots , v_n)} 
^{ langle &char , grangle } &num $ iff $ langle sem { v_1 } 
^{ langle &char , grangle } , ldots , sem { v_n } 
^{ langle &char , sem { p 
^n } 
^{ langle &char , grangle } $ . 
^ item $ 
^{ langle &char , grangle } &num $ iff $ sem { phi } 
^{ langle &char , grangle } 1 $ and $ sem { psi } 
^{ langle &char , grangle } &num $ . 
^ thus , with respect to a model $ m $ , an { sc smrs } can be viewed as denoting an element of $ &name p } ( g) $ , where $ &char $ is the set of variable assignment functions ( i.e. , elements of $ &char $ assign the variables $ &char , ldots $ and $ &char , ldots $ their denotations): [ 0.05in ] $ begin { array }{@{} l@{}} sem { smrs } 
^m { g : gmbox { is a variable assignment } &website } mbox { function and } &name smrs } end { array } $ 
^ we now consider the semantics of the algebra . 
^ this must define the semantics of the operation $ op $ in terms of a function $ &char $ which is defined entirely in terms of the denotations of $ op $ 's arguments . 
^ in other words , $ sem { op ( &name , &name &char ( sem { a_1 } , sem { a_2 }) $ for some function $ &char $ . 
^ intuitively , where the { sc smrs } of the { sc sement } $ a_1 $ denotes $ g_1 $ and the { sc smrs } of the { sc sement } $ a_2 $ denotes $ g_2 $ , we want the semantic value of the { sc smrs } of $ op ( &name , a_2) $ to denote the following : abovedisplayskip &name belowdisplayskip &name g_1cap &name cap sem { hook ( a_1 ) hole ( &name but this { em cannot } be constructed purely as a function of $ g_1 $ and $ g_2 $ . 
^ the solution is to add hooks and holes to the denotations of { sc sements } ( cf. &name , &num ) . 
^ we define the denotation of a { sc sement } to be an element of $ &num times &num times &name p } ( g) $ , where $ &name &char $ , as follows : begin { defn }{ denotations of { sc sement } s } if $ aneq bot $ is a { sc sement } , $ sem { a } 
^m langle [ i], [ &char " ] , &name $ where : begin { enumerate } topsep -1pt plus &name minus &name &website item $ [ &char ] mbox {{ it hook }} ( a) $ item $ [ &char " ] mbox {{ it hole }} ( a) $ item $ &char { g : &name mbox {{ it smrs }} ( a)} $ end { enumerate } $ sem { bot } 
^m langleemptyset , emptyset , emptysetrangle $ end { defn } so , the meanings of { sc sement } s are ordered three-tuples , consisting of the hook and hole elements ( from $ &num $ ) and a set of variable assignment functions that satisfy the { sc smrs } . 
^ we can now define the following operation $ &char $ over these denotations to create an algebra : begin { defn }{ semantics of the semantic construction algebra } $ langle &name &num times &name p } ( &char ) , frangle $ is an algebra , where: [ 0.05in ] $ begin { array }{@{} l@{}} &char ( langleemptyset , emptyset , emptysetrangle , langle [ i_2], [ i' &num ] , g_2rangle ) langleemptyset , emptyset , emptysetrangle &char ( langle [ i_1], [ i' &num ] , g_1rangle , langleemptyset , emptyset , emptysetrangle ) langleemptyset , emptyset , emptysetrangle &char ( langle [ i_1], [ i' &num ] , g_1rangle , langle [ i_2 ] , emptyset , g_2rangle langleemptyset , emptyset , emptysetrangle &char ( langle [ i_1], [ i' &num ] , g_1rangle , langle [ i_2], [ i' &num ] , g_2rangle ) &website } langle [ i_2], [ i' &num ] , g_1cap g_2cap g' rangle end { array } $ [ 0.05in ] where $ g' { g : &char ( i_1 ) &char ( i' _2)} $ end { defn } and this operation demonstrates that semantic construction is compositional : begin { theorem }{ semantics of semantic construction is compositional } the mapping $ sem {} : langle sigma , oprangle longrightarrow langle langle &char , i , &name , frangle $ is a homomorphism ( so $ sem { op ( &name , &name ( sem { a_1 } , sem { a_2 }) $ ) . 
^ end { theorem } this follows from the definitions of $ sem {} $ , $ op $ and $ &char $ . 
^ holes } label { holes-section } 
^ we now start considering the elaborations necessary for real grammars . 
^ as we suggested earlier , it is necessary to have multiple labelled holes . 
^ there will be a fixed inventory of labels for any grammar framework , although there may be some differences between variants.footnote { for instance , &name and &name ( &num ) omit the distinction between { sc spr } and { sc subj } that is often made in other { sc hpsg } s.} in { sc hpsg } , complements are represented using a list , but in general there will be a fixed upper limit for the number of complements so we can label holes { sc &name , { sc &name , etc. the full inventory of labels for the { sc erg } is : { sc subj , spr , spec , &name , &name , &name and { sc mod } ( see &name and &name , &num ) . 
^ to illustrate the way the formalization goes with multiple slots , consider $ op_ { subj } $ : begin { defn }{ bf the definition of $ op_ { subj } $ } $ op_ { subj } ( &name , a_2) $ is the following : if $ a_1bot $ or $ a_2bot $ or $ mbox {{ em hole }} _ { subj } ( a_2 ) emptyset $ , then $ op_ { subj } ( &name , &name ) bot $ . 
^ and if $ exists &char neq mbox {{ it subj }} $ such that : |mbox {{ em hole }} _l ( a_1 ) cup mbox {{ it hole }} _l ( &name then $ mbox {{ it op }} _ { subj } ( &name , &name ) bot $ . 
^ otherwise : begin { enumerate } topsep &name plus &name minus &name &website item $ mbox {{ it hook }} ( op_ { subj } ( &name , &name ) ) mbox {{ it hook }} ( a_2) $ % item $ mbox {{ it hole }} _ { subj } ( op ( &name , &name ) ) mbox {{ it hole }} _ { subj } ( a_1) $ item for all labels $ lneq subj $ : $ mbox {{ it hole }} _l ( op_ { subj } ( &name , &name ) ) mbox {{ it hole }} _ { l } ( a_1 ) cup mbox {{ it hole }} _ { l } ( a_2) $ item $ mbox {{ it lzt }} ( op_ { subj } ( &name , &name ) ) mbox {{ it lzt }} ( a_1 ) oplus mbox {{ it lzt }} ( a_2) $ item $ mbox {{ it eq }} ( op_ { subj } ( &name , &name ) ) &name ( eq ( a_1 ) cup eq ( a_2 ) cup $ &name $ { mbox {{ it hook }} ( a_1 ) mbox {{ it hole }} _ { subj } ( a_2)}) $ where $ &name $ stands for { it transitive closure } . 
^ end { defn } 
^ there will be similar operations $ op_ { comp1 } $ , $ op_ { comp2 } $ etc for each labelled hole . 
^ these operations can be proved to form an algebra $ langle sigma , op_ { subj } , op_ { comp1 } , ldotsrangle $ in a similar way to the unlabelled case shown in &name ref { op-is-function } . 
^ a little more work is needed to prove that $ op_l $ is closed on $ sigma $ . 
^ in particular , with respect to clause &num of the above definition , it is necessary to prove that $ op_l ( &name , &name ) bot $ or for all labels $ l' $ , $ |mbox {{ em hole }} _ { l' } ( op_l ( &name , &name &num $ , but it is straightforward to see this is the case . 
^ these operations can be extended in a way to handle simple constituent coordination of the kind that is currently dealt with in the { sc erg } ( e.g. , { em &name sleeps and talks } and { em &name and &name sleep } ) ; such cases involve daughters with non-empty holes of the same label , and the semantic operation equates these holes in the mother { sc sement } . 
^ section { scopal 
^ the algebra with labelled holes is sufficient to deal with simple grammars , such as that in &name and &name ( &num ) , but to deal with scope , more is needed . 
^ it is now usual in constraint based grammars to allow for underspecification of quantifier scope by giving labels to pieces of semantic information and stating constraints between the labels . 
^ in { sc mrs } , labels called { it handles } are associated with each { sc ep } . 
^ &name relationships are represented by { sc ep } s with handle-taking arguments . 
^ if all handle arguments are filled by handles labelling { sc ep } s , the structure is fully scoped , but in general the relationship is not directly specified in a logical form but is constrained by the grammar via additional conditions ( handle constraints or { it hcons } ).footnote { the underspecified scoped forms which correspond to sentences can be related to first order models of the fully scoped forms ( i.e. , to models of { sc wff } s without labels ) via supervaluation ( e.g. , &name , &num ) . 
^ this corresponds to stipulating that an underspecified logical form $ &char $ entails a base , fully specified form $ phi $ only if all possible ways of resolving the underspecification in $ &char $ entails $ phi $ . 
^ for reasons of space , we do not give details here , but note that this is entirely consistent with treating semantics in terms of a description of a logical formula . 
^ the relationship between the { sc sements } of non-sentential constituents and a more standard " formal language such as $ lambda $ -calculus will be explored in future work . 
^ a variety of different types of condition are possible , and the algebra developed here is neutral between them , so we will simply use $ rel_h $ to stand for such a constraint , intending it to be neutral between , for instance , $ qeq $ ( qeq : equality modulo quantifiers ) relationships used in { sc mrs } and the more usual $ leq $ relationships from { sc udrt } ( &name , &num ) . 
^ the conditions in hcons are accumulated by append . 
^ to accommodate scoping in the algebra , we will make hooks and holes { em pairs } of indices and handles . 
^ the handle in the hook corresponds to the { sc ltop } feature in { sc mrs } . 
^ the new vocabulary is : begin { enumerate } topsep -1pt plus &name minus &name &website item the absurdity symbol $ bot $ . 
^ item handles $ h_1 , h_2 , ldots $ item indices $ &name , &name , ldots $ , as before item $ &char $ -predicates which take handles and indices as arguments item $ rel_h $ and $ $ . 
^ the revised definition of an { sc ep } is as in { sc mrs } : begin { defn }{ elementary predications ( { sc ep } s)} label { eps } an { sc ep } contains exactly &num components : begin { enumerate } topsep -2pt plus &name minus &name &website item a handle , which is the label of the { sc ep } item a relation item a list of &num or more ordinary variable arguments of the relation ( i.e. , indices ) item a list of &num or more handles corresponding to scopal arguments of the relation . 
^ this is written 
^ h: &char ( a $ &num , ldots, $ a $ _n $ , sa $ &num , ldots, $ sa $ &char $ ) . 
^ for instance , $ mbox { h : every } ( &char , h_1 , h_2) $ is an { sc ep }.footnote { note { em every } is a predicate rather than a quantifier in this language , since { sc mrs } s are partial descriptions of logical forms in a base language.} end { defn } 
^ we revise the definition of semantic entities to add the hcons conditions and to make hooks and holes pairs of handles and indices . 
^ { bf &name &name where $ h_1 $ and $ h_2 $ are handles , $ h_1 rel_h h_2 $ is an &name condition . 
^ set $ sigma $ of semantic entities } $ sin sigma $ if and only if $ sbot $ or $ &char langle &name , &name , &name , &name , s_5rangle $ such that : begin { itemize } topsep &name plus &name minus &name &website item $ s_1 { [ &char , i]} $ is a hook ; item $ s_2 emptyset $ or $ { [ &char " , i' ]} $ is a hole ; item $ s_3 $ is a bag of { sc ep } conditions item $ s_4 $ is a bag of { sc hcons } conditions item $ s_5 $ is a set of equalities between variables . 
^ end { itemize } end { defn } { sc sement } s are : $ [ h_1 , i_1]{ mbox {{ em holes }}} [ mbox {{ em eps }}] [ mbox {{ em hcons }}]{ mbox {{ em eqs }}} $ . 
^ we will not repeat the full composition definition , since it is unchanged from that in sref { simple } apart from the addition of the append operation on hcons and a slight complication of $ eq $ to deal with the handle / index pairs : $ mbox {{ em eq }} ( op ( &name , &name ) ) &name ( eq ( a_1 ) cup eq ( a_2 ) cup $ $ { mbox {{ em hdle }} ( mbox {{ em hook }} ( a_1 ) ) mbox {{ em hdle }} ( mbox {{ em hole }} ( a_2 ) ) , mbox {{ em ind }} ( mbox {{ em hook }} ( a_1 ) ) mbox {{ em ind }} ( mbox {{ em hole }} ( a_2))}) $ where $ &name $ stands for { em transitive closure } as before and { em hdle } and { em &name access the handle and index of a pair . 
^ we can extend this to include ( several ) labelled holes and operations , as before . 
^ and these revised operations still form an algebra . 
^ the truth definition for { sc sements } is analogous to before . 
^ we add to the model a set of labels $ &char $ ( handles denote these via $ &char $ ) and a well-founded partial order $ leq $ on $ &char $ ( this helps interpret the { em hcons } ; cf. &name ( &num ) ) . 
^ &char { sc sement } then denotes an element of $ &name h } times { cal p } ( g) $ , where the $ &name h } $ &char ( $ ltimes &num $ ) are the new hook and holes . 
^ note that the language $ sigma $ is first order , and we do not use $ lambda $ -abstraction over higher order elements.footnote { even though we do not use $ lambda $ -calculus for composition , we could make use of $ lambda $ -abstraction as a representation device , for instance for dealing with adjectives such as { it former } , cf. , &name ( &num ).} for example , in the standard montagovian view , a quantifier such as { em every } is represented by the higher-order expression $ lambda &name &name &char ( &char ( &char ) , &char ( x)) $ . 
^ in our framework , however , { em every } is the following ( using qeq conditions , as in the lingo { sc erg }): [ 0.05in ] $ begin { array }{@{} &char @{}} mbox {} [ h_f , x]{ [ ]_ { subj }, [ ]_ { comp1 }, [ &char " , x]_ { spec } , ldots } &name [ h_e : mbox {{ it every }} ( &char , h_r , h_s)] [ h_r &char h' ]{} end { array } $ and { em dog } is : $ begin { array }{@{} &char @{}} mbox {} [ h_d , y]{ [ ]_ { subj }, [ ]_ { comp1 }, [ ]_ { spec } , ldots } [ h_d : mbox {{ it dog }} ( y)] [ ]{} end { array } $ [ 0.05in ] so these composes via $ op_ { spec } $ to yield { em every dog }: [ 0.05in ] $ begin { array }{@{} l@{}} [ h_f , x]{ [ ]_ { subj }, [ ]_ { comp1 }, [ ]_ { spec } , ldots } &name [ h_e : mbox {{ it every }} ( &char , h_r , h_s ) , h_d : mbox {{ it dog }} ( &char ) ] &name [ h_r &char h' ]{ h' h_d , xy } end { array } $ [ 0.05in ] this { sc sement } is semantically equivalent to: [ 0.05in ] $ begin { array }{@{} l@{}} [ h_f , x]{ [ ]_ { subj }, [ ]_ { comp1 }, [ ]_ { spec } , ldots } &name [ h_e : mbox {{ it every }} ( &char , h_r , h_s ) , h_d : mbox {{ it dog }} ( &char ) ] [ h_r _q h_d]{} end { array } $ [ 0.05in ] a slight complication is that the determiner is also syntactically selected by the &char $ " $ via the { sc spr } slot ( following &name and &name ( &num ) ) . 
^ however , from the standpoint of the compositional semantics , the determiner is the semantic head , and it is only its { sc spec } hole which is involved : the &char $ " $ must be treated as having an empty { sc spr } hole . 
^ in the { sc erg } , the distinction between intersective and scopal modification arises because of distinctions in representation at the lexical level . 
^ the repetition of variables in the { sc sement } of a lexical sign ( corresponding to { sc tfs } coindexation ) and the choice of type on those variables determines the type of modification . 
^ { bf intersective modification:} { em white dog }: [ 0.05in ] $ begin { array }{@{} r &char r@{}} mbox { dog:} & [ h_d , y]{ [ ]_ { subj }, [ ]_ { comp1 } , ldots, [ ]_ { mod }} & &name [ h_d : mbox {{ it dog }} ( y)] [ ]{} end { array } $ $ begin { array }{@{} r &char r@{}} mbox { white:} & [ h_w , x]{ [ ]_ { subj }, [ ]_ { comp1 } , .. , [ h_w , x]_ { mod }} & &name [ h_w : mbox {{ it white }} ( x)] [ ]{} end { array } $ $ begin { array }{@{} r &char r@{}} mbox { white dog:} & [ h_w , x]{ [ ]_ { subj }, [ ]_ { comp1 } , ldots, [ ]_ { mod }} ( &name [ h_d : mbox {{ it dog }} ( &char ) , h_w : mbox {{ it white }} ( x)] [ ] & &website }{ h_wh_d , xy } end { array } $ 
^ { bf &name &name { em probably walks }: [ 0.05in ] $ begin { array }{@{} r &char r@{}} mbox { walks:} & [ h_w , e' ]{ [ &char " , x]_ { subj }, [ ]_ { comp1 } , ldots, [ ]_ { mod }} & [ h_w : mbox {{ it walks }} ( &char " , x)] [ ]{} end { array } $ $ begin { array }{@{} r &char r@{}} mbox { probably:} & [ h_p , e]{ [ ]_ { subj }, [ ]_ { comp1 } , ldots, [ &char , e]_ { mod }} & &name [ h_p : mbox {{ it probably }} ( h_s)] [ h_s &char h]{} end { array } $ $ begin { array }{@{} r &char r@{}} mbox { probably } & [ h_p , e]{ [ &char " , x]_ { subj }, [ ]_ { comp1 } , ldots, [ ]_ { mod }} &name [ h_pmbox {:{ it probably }} ( h_s ) , h_wmbox {:{ it walks }} ( &char " , &char ) ] & ( op_ { mod } ) & &name [ h_s &char h]{ h_wh , ee' } end { array } $ 
^ and external arguments } label { control-section } 
^ we need to make one further extension to allow for control , which we do by adding an extra slot to the hooks and holes corresponding to the external argument ( e.g. , the external argument of a verb always corresponds to its subject position ) . 
^ we illustrate this by showing &num uses of { em expect } ; note the third slot in the hooks and holes for the external argument of each entity . 
^ in both cases , $ x' &char $ is both the external argument of { it expect } and its subject 's index , but in the first structure $ x' &char $ is also the external argument of the complement , thus giving the control effect . 
^ expect &num ( as in { em &name expected to sleep } ) $ [ h_e , e_e , x' _e]{ [ h_s , x' &char , x' _s]_ { subj }, [ h_ { c } , e_ { c } , x' _e]_ { comp1 } , ldots } $ $ [ h_e : mbox {{ em expect }} ( e_e , x' &char , h' &char ) ] [ h' &char &char h_ { c }]{} $ expect &num ( { em &name expected that &name would sleep } ) $ [ h_e , e_e , x' _e]{ [ h_s , x' &char , x' _s]_ { subj }, [ h_ { c } , e_ { c } , x' _ { c }]_ { comp1 } , ldots } $ $ [ &char : mbox {{ em expect }} ( e_e , x' &char , h' &char ) ] [ h' _e_q h_ { c }]{} $ although these uses require different lexical entries , the semantic predicate $ mbox {{ em expect }} $ used in the &num examples is the same , in contrast to montagovian approaches , which either relate &num distinct predicates via meaning postulates , or require an additional semantic combinator . 
^ the { sc hpsg } account does not involve such additional machinery , but its formal underpinnings have been unclear : in this algebra , it can be seen that the desired result arises as a consequence of the restrictions on variable assignments imposed by the equalities . 
^ this completes our sketch of the algebra necessary to encode semantic composition in the { sc erg } . 
^ we have constrained accessibility by enumerating the possible labels for holes and by stipulating the contents of the hooks . 
^ we believe that the handle , index , external argument triple constitutes all the semantic information that a sign should make accessible to a functor . 
^ the fact that only these pieces of information are visible means , for instance , that it is impossible to define a verb that controls the object of its complement.footnote { readers familiar with { sc mrs } will notice that the { sc key } feature used for semantic selection violates these accessibility conditions , but in the current framework , { sc key } can be replaced by { sc keypred } which points to the predicate alone.} although obviously changes to the syntactic valence features would necessitate modification of the hole labels , we think it unlikely that we will need to increase the inventory further . 
^ in combination with the principles defined in &name et &name ( &num ) for qeq conditions , the algebra presented here results in a much more tightly specified approach to semantic composition than that in &name and &name ( &num ) . 
^ 
^ compared with $ lambda $ -calculus , the approach to composition adopted in constraint-based grammars and formalized here has considerable advantages in terms of simplicity . 
^ the standard &name grammar approach requires that arguments be presented in a fixed order , and that they be strictly typed , which leads to unnecessary multiplication of predicates which then have to be interrelated by meaning postulates ( e.g. , the &num uses of { em expect } mentioned earlier ) . 
^ type raising also adds to the complexity . 
^ as standardly presented , $ lambda $ -calculus does not constrain grammars to be monotonic , and does not control accessibility , since the variable of the functor that is $ lambda $ -abstracted over may be arbitrarily deeply embedded inside a $ lambda $ -expression . 
^ none of the previous work on approaches to semantics has considered constraints on composition in the way we have presented . 
^ in fact , &name ( &num ) explicitly advocates nonmonotonicity . 
^ &name ( &num ) is also concerned with formalizing existing practice in unification grammars ( see also &name , &num ) , though he assumes &name unification , rather than { sc tfs } s . 
^ &name attempts to formalize his approach in the logic of unification , but it is not clear this is entirely successful . 
^ he has to divorce the interpretation of the expressions from the notion of truth with respect to the model , which is much like treating the semantics as a description of a logic formula . 
^ our strategy for formalization is closest to that adopted in &name &name grammar ( &name et &name , &num ) , but rather than composing actual logical forms we compose partial { em descriptions } to handle semantic underspecification . 
^ and future work } 
^ we have developed a framework for formally specifying semantics within constraint-based representations which allows semantic operations in a grammar to be tightly specified and which allows a representation of semantic content which is largely independent of the feature structure architecture of the syntactic representation . 
^ { sc hpsg } s can be written which encode much of the algebra described here as constraints on types in the grammar , thus ensuring that the grammar is consistent with the rules on composition . 
^ there are some aspects which cannot be encoded within currently implemented { sc tfs } formalisms because they involve negative conditions : for instance , we could not write { sc tfs } constraints that absolutely prevent a grammar writer sneaking in a disallowed coindexation by specifying a path into the lzt . 
^ there is the option of moving to a more general { sc tfs } logic but this would require very considerable research to develop reasonable tractability . 
^ since the constraints need not be checked at runtime , it seems better to regard them as metalevel conditions on the description of the grammar , which can anyway easily be checked by code which converts the { sc tfs } into the algebraic representation . 
^ because the { sc erg } is large and complex , we have not yet fully completed the exercise of retrospectively implementing the constraints throughout . 
^ however , much of the work has been done and the process revealed many bugs in the grammar , which demonstrates the potential for enhanced maintainability . 
^ we have modified the grammar to be monotonic , which is important for the chart generator described in &name et &name ( &num ) . 
^ a chart generator must determine lexical entries directly from an input logical form : hence it will only work if all instances of nonmonotonicity can be identified in a grammar-specific preparatory step . 
^ we have increased the generator 's reliability by making the { sc erg } monotonic and we expect further improvements in practical performance once we take full advantage of the restrictions in the grammar to cut down the search space . 
^ section * 
^ this research was partially supported by the national science foundation , &name number iri-9612682 . 
^ &name &name was supported by an &name ( &name ) research fellowship . 
^ we are grateful to &name &name , &name &name and the anonymous reviewers for their comments on this paper . 
^ section * { references } % first names are n't essential ... 
^ &name , &name [ &num ] ( ed. ) { em the core language engine } , { sc mit } press . 
^ &name , &name , &name &name , &name &name and &name &name [ &num ] an efficient chart generator for lexicalist grammars , { em the 7th international workshop on natural language generation } , &num . 
^ &name , &name , &name &name , &name &name and &name &name [ &num ] &name &name &name : an introduction , manuscript at { &website } 
^ egg , &name [ &name { em wh }-questions in &name &name &name &name , { em journal of semantics } , &num : &num . 
^ &name , &name [ &num ] ambiguity in &name &name , { em linguistics and philosophy } , &num : &num . 
^ &name , &name &name [ &num ] semantic interpretation , { em the 27th &name &name for the association for computational &name ( &org-89)} , &num . 
^ &name , &name [ &num ] &name and processing , &name &name ( ed. ) { em handbook of contemporary semantic theory } , &num , &name . 
^ &name , &name and &name &name [ &num ] { em &name &name &name grammar } , university of &name press . 
^ &name , &name [ &num ] dealing with ambiguities by : construction , &name and &name , { em journal of semantics } , &num : &num . 
^ &name , &name , and &name &name [ &num ] { em &name &name : an introduction } , &name &name . 
^ &name , &name [ &num ] { em an introduction to approaches to grammar } , &name &name . 
^ &name , &name [ &num ] &char compositional approach to &name &name &name , { em linguistics and philosophy } , &num : &num . 
^ &name , &name , &name &name and &name &name [ &num ] an introduction to unification categorial grammar , &name &name , &name &name and &name &name ( eds ) , { em categorial grammar , unification grammar , and parsing : working papers in cognitive science , &name &name , &num , &name for cognitive science , university of &name . 
^ &name
</text_normal>
</message_body>
</message>