<message>
<date> wed, 7 aug 2002 08:26:52 -0400 (edt) </date>
<from> edu </from>
<to> edu </to>
<subject>
<text_normal> 

^ re : &name &name 
</text_normal>
</subject>
<content-type> text/plain; charset=us-ascii </content-type>
<message_body>
<text_normal> 

^ congratulations ! 
^ i am sure we can pass along any conclusions that we come up with today . 
^ &name 
^ &name wed , &num &name &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ i appreciate the detailed information . 
^ &name , as my wife gave birth to my first kid , i do n't think i will be joining the meeting today . 
^ i am sorry for not joining the meeting . 
^ please let me know the meetings " verdict about stream ids later . 
^ thank you . 
^ &name . 
^ on &name , &num &name &num , &name &name wrote : 
<text_embedded> 

^ hi &name , 
^ no problem , let me explain more the utility of the keys for aggregate boxes . 
^ not all aggregate boxes are preceded by a restream , sometimes the boxes will just work on keys how they are . 
^ take the example of an aggregate box that calculates the average heartbeat of each soldier . 
^ the soldiers might just be distinguished by &name , so the box can automatically keep &num state per &name ( soldier ) . 
^ as far as othogonal grouping , consider tumble which closes the " current state " every time it sees a new set of group by attributes . 
^ if the new set of group by attributes differs by a stream identifier attribute ( or the set of attributes that restream currently groups into an &name ) , this is not what you want to happen . 
^ stream identifier attributes are 'special " because seeing a new one with an aggregate box does not necessarily close a state - because multiple states are maintained simultaneously ; &num per stream id . 
^ consider the following example : 
^ &num . 
^ ( &name &num , &char &num ) &num . 
^ ( &name &num , &char &num ) &num . 
^ ( &name &num , &char &num ) 
^ note that none of these tuples needs to close a state , but if you treat &name as a regular group by attribute , you will be closing states after tuples &num and &num . 
^ thus &name ( or if we remove it , the additional grouping that is done by restream ) is orthogonal to the regular group-by attributes of tumble . 
^ regarding your question about joins , &name says that we have no idea how join will work yet - it might not even be windowed . 
^ &name 
^ on mon , &num &name &num , &name &name wrote : 
<text_embedded> 

^ i think i was wrong . 
^ just forget what i said . 
^ sorry . 
^ returning to your first question , i do n't think i can judge whether the negatives of increasing the complexity of the aggregate boxes outweigh the positives of doing that or not . 
^ i just want to hear others " opinions in the meeting . 
^ but personally , i do n't like to have stream ids because their relative utility seems low to me ( they are hidden from box modifiers ) . 
^ in the mean time i do n't think i fully understand the complexity of the aggregate boxes ( having &num orthoganal groupings ) . 
^ could you show me some examples ? 
^ i think it will be helpful for the others also . 
^ thank you , 
^ &name . 
^ p.s. do you know if joins ( which are windowed ) can work fine with tuples not sorted by the timestamp order ? 
^ if you have a join with &num min time winodw such that the timestamp sequences of both the left and right input tuples are commonly ( &num : &num pm , &num : &num pm , &num : &num pm , &num : &name , &num : pm , &num : &name , . ... ) , what would you do ? 
<text_embedded> 

^ hi &name , 
^ i am not sure what you mean , but i think you are saying that for aggregate operators , timestamps need to be kept around for each &name . 
^ but i think that 's only because there is &num state for each &name , so even if we do n't have &name we will still have more than &num state . 
^ so i 'm not sure how throwing away this system will help . 
^ &name 
^ on mon , &num &name &num , &name &name wrote : 
^ we reordering ) " issue 
^ if 
</text_embedded>

</text_embedded>

</text_embedded>

</text_embedded>
</message_body>
</message>