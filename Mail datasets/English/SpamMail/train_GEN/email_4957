<message>
<date> thu, 8 aug 2002 23:01:00 -0400 (edt) </date>
<from> edu </from>
<to> edu </to>
<subject>
<text_normal> 

^ re : some pseudocode for &name 
</text_normal>
</subject>
<content-type> text/plain; charset=us-ascii </content-type>
<message_body>
<text_normal> 

^ i have a tennis game then , how is &num : 45am ? 
^ &name 
^ on &name , &num &name &num , &name &name wrote : 
</text_normal>
<text_embedded> 

^ let 's discuss this over a meeting . 
^ how is 7am tomorrow ? 
^ &name &name &name &name &name university ph. &name &name &num &email 
^ on &name , &num &name &num , &name &name wrote : 
<text_embedded> 

^ hi all , 
^ the following is the pseudocode for the &name class . 
^ it makes the following assumptions : 
^ &num ) the fieldext must be rewritten to accept ports ( in addition to offset and size ) 
^ &num ) an evaluate method of most of the predicates must be added to accept &num tuples ( in addition to the method that accepts &num ) 
^ &num ) a priority queue has been written separately with the following functionality : &char ) can be traversed in ascending or descending order ii ) a lowest ( ) method that returns the first node in the queue ( the first node meaning the lowest element in the queue if the queue is in ascending order , the highest otherwise ) iii ) a removelowest ( ) method that removes the lowest element in the queue iv ) an insert method that inserts a node in the queue in the correct location using the provided &name method ( see below ) 
^ &num ) an tuple in the buffer can be emitted if &char ) the buffer is full ii ) that element has been in the queue longer than the parameter maxtime ( kind of - it actually uses system timestamps not local times ) 
^ class &name : &name 
^ &name ( buffer_node ) _buffer ; &name [ ] preds_compare ; &name [ ] preds_equal ; &name _maxtime ; 
^ struct buffer_node { string tuple ; 
^ tuple last_emitted ; 
^ constuctor ( &name * atts , int bsize , int num_atts , timestamp maxtime ) _maxtime maxtime ; &name [ ] _leftatts &name ( atts , num_atts , &num ) &name [ ] _rightatts &name ( atts , num_atts , &num ) _buffer new priorityqueue ( buffernode) ( bsize , _atts , num_atts ) ; for each att in num_atts fieldext left _leftatts [ att ] ; &name right _rightatts [ att ] ; switch att.type { case &name : preds_compare [ att ] new &name ( left , right ) ; preds_equal [ att ] new &name ( left , right ) ; case float : preds_compare [ att ] new &name ( left , right ) ; preds_equal [ att ] new &name ( left , right ) ; case string : preds_compare [ att ] new &name ( left , right ) ; preds_equal [ att ] new &name ( left , right ) ; case timestamp : preds_compare [ att ] new &name ( left , right ) ; preds_equal [ att ] new &name ( left , right ) ; 
^ function &name ( ) //_tuple has already been set by scheduler 
^ timestamp currtime gettimestamp ( _tuple ) ; //first check to see if there are any expired tuples in the _buffer for each node in _buffer in descending order if currtime - &name ( node.tuple ) ) _maxtime removeuntilnode ( node ) ; 
^ if ( ! 
^ &name ) &name ( _tuple ) ; else if ( &name ( _buffer.lowest ( ) , _tuple ) ( &num ) emitlowest ( ) ; &name ( _tuple ) ; else if ( &name ( last_emitted , _tuple ) ( &num ) outstream.concat ( _tuple ) ; num_tuples_emitted++ ; last_emitted _tuple ; 
^ function removeuntilnode ( buffernode elem ) for each node in _buffer in ascending order if ( node ! 
^ elem ) emitlowest ( ) else emitlowest ( ) break ; 
^ function emitlowest ( ) outstream.concat ( _buffer.lowest ( ) ) ; num_tuples_emitted++ ; last_emitted buffer.removelowest ( ) ; 
^ function &name ( string tuple ) _buffer.insert ( tuple ) ; 
^ int &name ( string &name , string tuple2 ) for each att in num_atts if pred_compare [ att ].evaluate ( tuple1 , tuple2 ) return &num ; else if ! 
^ pred_equal [ att ].evaluate ( tuple1 , tuple2 ) return &num ; return &num ; 
^ &name [ ] &name ( string atts , int num_atts , bool whichport ) //this method is exactly the same as what is done in the restream method //the only difference is that once it creates the instance of the &name class , it sets the port to &name 
</text_embedded>

</text_embedded>
</message_body>
</message>